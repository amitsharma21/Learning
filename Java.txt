1) Integer arr[] = new Integer[3] || int arr[]={1,2,3,4} || int arr[] = new int[4]{1,2,3,4};
    A) arr.length;
    B) Arrays.sort(arr): sort array in asceding order
    C) Arrays.sort(arr,fromIndex,toIndex): sort array in range [fromIndex, toIndex);
    D) 
    	class customComparator implements Comparator<Integer>{
    	    public int compare(Integer a, Integer b){
    	    	if(a>b){
    	    	   return -1 //no swapping 
    	    	}else{
    	    	   return 1 // swapping
    	    	}
    	    }
    	}
    
    	Arrays.sort(arr,new CustomComparator()) //!sometime this error Come: Exception in thread "main" java.lang.IllegalArgumentException Comparison method violates its general contract: for this add 2 conditions if there are 3 check and 3 conditions if there are 4 checks and so on.


2) ArrayList<Integer>arr=new ArrayList<Integer>();
    A) arr.add(value)
    B) arr.get(index)
    C) arr.size()
    D) arr.set(index, new value)
    E) Collections.sort(arr)
    F) class customComparator implements Comparator<Integer>{
    	    public int compare(Integer a, Integer b){
    	    	if(a>b){
    	    	   return -1 //no swapping 
    	    	}else{
    	    	   return 1 // swapping
    	    	}
    	    }
    	}
    	Collections.sort(arr,new CustomComparator())
    G) for creating Arraylist with initial size we need to create our custom function java does 	
       not have function for this.
       
       ensureSize(Arraylist<Integer>arr,int size){
           for(int i=0;i<size;i++){
               arr.add(null)
           }
       }
    H) List<String> arr=new ArrayList<String>(Arrays.asList("Initializing the arrayList","Dont create this array before and try to use asList function on that","that will give error"));

3) String arr=""
    A) arr.length()
    B) arr.charAt(index)
    C) arr.equals(new String)
    D) arr.append(new String) or use + operator
    E) we cant replace the element at given index in string directly but we can use substring 
       method:
       string cur="pankaj"
       char c='d';
       arr=arr.substring(0,2)+d+arr.substring(3) ====>padkaj
    F) arr.compareTo(new String)-> 
    		return 0 if arr is equal to new String,
    		return positive int if arr is lexigraphically greater than new String 
    		return negative int if arr is lexigraphically smaller than new String


4) PriorityQueue<Integer>arr=new PriorityQueue<Integer>() :min Heap
   PriorityQueue<Integer>pq=new PriorityQueue<>(Collections.reverseOrder()) :max Heap
    A) arr.add(value)
    B) arr.peek()
    C) arr.isEmpty()
    D) arr.poll()
    E) arr.size()
    F) PriorityQueue with Pair:
    
    	class maxHeapComparator implements Comparator<Pair<Integer,Integer>>{
	    public int compare(Pair<Integer,Integer>A,Pair<Integer,Integer>B){
		if(A.key>B.key) return -1;
		else if(A.key<B.key) return 1;
		else return 0;
	    }
	}
	
	class minHeapComparator implements Comparator<Pair<Integer,Integer>>{
	    public int compare(Pair<Integer,Integer>A,Pair<Integer,Integer>B){
		if(A.key<B.key) return -1;
		else if(A.key>B.key) return 1;
		else return 0;
	    }
	}
	PriorityQueue<Pair<Integer,Integer>>minHeap=new PriorityQueue<>(new minHeapCustomComparator()); //min Heap
	PriorityQueue<Pair<Integer,Integer>>maxHeap=new PriorityQueue<>(new maxHeapCustomComparator());	//max Heap
	
5) Pair<Integer,String>arr= new Pair<Integer,String>(key,value)
    A) arr.getKey()
    B) arr.getValue()
    
6) Queue<Integer>arr= new LinkedList<Integer>()
    A) arr.add(value)
    B) arr.isEmpty()
    C) arr.remove(): it return the front value and delete that
    D) arr.size()
    
7) Stack<Integer>arr= new Stack<Integer>()
    A) arr.push(value)
    B) arr.peek()
    C) arr.pop(): it return the top element and delete that
    D) arr.isEmpty()
    E) arr.size()
    
8) HashMap<Integer,Integer>arr=new HashMap<Integer,Integer>()
    A) arr.put(key,value)
    B) arr.size()
    C) arr.containsKey(key)
    D) arr.containsValue(value)
    E) arr.get(key)
    F) arr.remove(key)
    G) arr.isEmpty()
    H) Traversing of hashMap
    		for(Map.Entry<Integer,Integer>mapElement:arr.entrySet()){
    			Integer a=mapElement.getKey();
    			Integer b=mapElement.getValue();
    		}
    I) traversing in another way: arr.entrySet().stream().forEach(entry->{
    					int a=entry.getKey();
    					int b=entry.getValue();
    					});
    J) traversing in sorted keys order:
    	arr.entrySet().stream().sorted(Map.Entry.comparingByKey().forEach(entry->{
    		int a= entry.getKey();
    		int b= entry.getValue();
    		}))
 
9) HashSet<Character>arr= new HashSet<Character>()
    A) arr.add(value);
    B) arr.size()
    C) arr.contains(value)
    D) arr.remove(value)
    E) arr.isEmpty()
    F) Traversing of HashSet
    			for(Character a : arr){
    			    System.out.println(a);10
    			}

A)Swap 2 number inside function
B)Pair in java
C)Priority_Queue with pair


   
10) Optional<String>obj = Optional.ofNullable("I have taken the String as datatype it can be any other datatype or it can also be null");
    Optional<Cat>obj = Optional.of("We do not use ofNullable when we are 100% sure that we will never pass null into optional");
        A) obj.get(): it return the object present inside the optional. 
        B) obj.isPresent(): It return true if optional contain some value whereas return false if optional contain null
        C) obj.orElseThrow(): It is exactly similar to obj.get()
        D) obj.orElse("Return this value"): if optional contains not null value it will return that. but if the optional contains null then it will return the value that we pass as an argument to this fxn.
        E) obj.orElseGet(): if optional is empty than it will use the lamda method to supply the default value. we need to pass the lamda inside the function


11) Lamda Expression:
    A) FunctionalInterface: It is the interface hanving only one abstract method. this interface could contain other default method or static method but only one abstract method.
    B) lamda functions can only be used with FunctionalInterface
    C) Lamda expression is shortcut for defining the implementation of functional Interface.
    D) Example:

        @FunctionalInterface                                                                                                @FunctionalInterface
        public interface Printable{                                                                                         public interface Printable{
            void print(String arg);                                                                                             void print();
        }                                                                                                                   }                   

        class Solution{                                                                                                     class Solution{
            public static void main(String[] args){                                                                             public void static main(String[] args){
                Printable obj = (s) ->{ sout("this is multiline lamda expression );};                                               Printable obj=()-> sout("this is single line lamda expression");
                obj.print("the above lamda expression is implementation of print fxn that");                                        obj.print();
            }                                                                                                                }
        }                                                                                                                  

12) Streams In java:
    List<int>arr = Arrays.asList(1,2,3,4,5);
    A) arr.stream().forEach(val -> sout(val)): it convert the arr to stream and print each element of list. after foreach we cant do any operation as its terminal operation
    B) arr.stream().map(val -> val*10).collect(Collectors.toList()): map is intermediate operation it map the each element of stream to new element and at last each element is collected to list
    C) arr.stream().filter(val-> val>3).map(val -> val*10): first it filter all the elements means we will only get element greater than 3 and then after that its normal map operation
    D) arr.stream().filter(val -> val>3).findFirst(): it gives the optinal output null if nothing found or else return the first value.
    
13) Future in Java:

