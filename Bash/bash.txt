1) Each Bash script start with the line #! /bin/bash  
#!: shebang

2) echo "printing string"
   echo $variable

3) permission of file:
    _rwxrw_r__: there are 10 characters in this. first character represent the type of file whether it is file or directory
                next 3 characters are the permission for super owner
                next 3 characters are the permission for the group members
                next 3 characters are the permission for rest of members.

    changing the permission of the file: chmod [class][operator][permision] file name
        class: u(user),g(group),o(other),a(All)
        operator: +,-
        permission: r,w,x

        eg: chmod ugo+wx file.txt
            chmod uo-x file.txt
            chmod +x file.txt => this will add the execute permision to all the user together this is alternate to chmod a+x file.txt

4) Comments:
    single line comment: #single line comment start with # symbol
    multiline comment: <<COMMENT
                            this is fist line of comment
                            this is second line of comment
                        COMMENT

5) Quotes: single quotes and double quote behave differently in bash scripting if used with variables. normaly they work same
    eg: name = "amit"
        echo "my name is $name" ===o/p===> my name is amit

        name = "amit"
        echo 'my name is $name' ===o/p===> my name is $name

    basically we can not access variables inside single quotes.

6) Variables: A) variables are case sensitive in bash
              B) while assigning value there shoud not be space on either side of ()=) eg. a = 12 , b =23, c= 23  ---> all the 3 assignments are incorrect as there are space around (=).
              C) use quotes either single of double while defining variable if the value is more than one word. eg. name="Amit Sharma"
              D) no need to mention the data type of variable like we do in c++(int a=12) bash will dynamically assign the data type to the variable.
              E) initializing the variable: we dont use $ while initializing
                 name="Amit Sharma"
              F) while reading the value (or when we use the variable we use $): echo "my name is $name"
              G) Command Line Arguments: 
                we pass the command line argument while running the script. eg: ./bash_script arg1 arg2 'arg3 with spaces' arg4
                $0 specifies the name of the script to be invoked.
                $1-$9 stores the names of the first 9 arguments or can be used as the arguments' positions.
                $# specifies the total number (count) of arguments passed to the script.
                $* stores all the command line arguments by joining them together.
                $@ stores the list of arguments as an array.
                $? specifies the process ID of the current script.
                $$ specifies the exit status of the last command or the most recent execution process.
                $! shows ID of the last background job.
                
                we can read the command line argument with the help of $0 to $9
                we can also read the commnad line argument with the help of array: arr=("$@") echo ${arr[0]}

              
              H) difference between ${} and $():
              ${}: it is used to differentiate the variables from normal string. eg=> name=Amit
                                                                                      echo "my name is $nameSharma"=> it will treat the variable as $nameSharma but that is wrong as our var name is $name
                                                                                      echo "my name is ${Amit}Sharma"=> it will print my name is AmitSharma

              $(): it is used to evaluate the result of command eg: echo "today date is $date" => it will not work fine as it will treat $date as variable which we have not defined
                                                                    echo "today date is $(date)" => it will print today date is wednesday 16th August ...
                   it is also called command substitution 

7) Read User input: similar to cin in c++. we dont use the $ sign with read.
                A) read <var_name>
                B) read <var1> <var2> <var3>: it is used to read multiple values from user.
                C) read : if we dont use any variable after read than bydefault the bash will store the values in $REPLY variable
                    eg: read
                       echo "entered value is: $REPLY"
                D) read -p PROMPT <variable_name> : used to read the value with prompt.
                    eg: read -p "name:" <variable_name>  
                        read -P "reading multiple values with prompt" <var1> <var2> <var3>
                E) read -sp PROMPT <variable_name>: used to read the value in silent mode in this whatever user enter did not get display on screen similar to what ubuntu do for password
                F) read -a array: in this all the user entered values get stored in array 
                   accessing those value ===> echo "${array[0]}, ${array[1]}"

8) sleep in bash: it is utility provided by bash to stop the execution of script for some fixed amount of time.
    sleep number[suffix]
    possible value of suffix: d(day),h(hour),m(minute),s(second) ==> if we dont provide any suffix then default suffix is second
    sleep 9 => sleep for 9 second
    sleep 9m => sleep for 9 minutes
    sleep 1m 9s => sleep for 1 minute 9 second
    sleep 2d 1m 9s => sleep for 2 day 1 minute 9seconds

9) Arithematic operators: Bash support 11 Arithematic operator: 
    + => addition
    - => substraction
    * => multiplication
    / => division
    % => modulo
    += => increment by constant  :: eg: $((x+=y)) value of x is incremented by y
    -= => decrement by constant  :: eg: $((x+=y)) value of x is decremented by y
    *= => multiplication by constant  :: :: eg: $((x*=y)) value of x is multiplied by y
    /= => division by constant
    %= => modulo by constant
    ** => power  :: eg: $((x**y)) value of x is not changed in this but we can store the result in other variable
    A) way to do the arithematic operation
        x=8
        y=2
        sum=$((x+y)) ===> o/p sum=10
        increment=$((x+=y)) ===> o/p increment=10
        pow=$((x**y)) ===> o/p pow=64
    B) let Command: it is command that allow us to perform arithematic operation
        let "sum=$((x+y))"
        let "increment=$((x+=y))"
        let "pow=$((x**y))"

10) If statement:
                A)  if [ condition ]; then  => in this line spacing is important
                        echo "in this line spacing is not important "
                    fi
                B)  nested If
                    if [ condition ]; then
                        if [ condition ]; then
                        echo "example of nested if"
                        fi
                    fi
                C) AND operator condition
                    if [ condition1 ] && [ condition2 ]; then
                    fi
                D) OR operator condition
                    if [ condition1 ] || [ condition2 ]; then
                    fi

11) if-else Statement: 
                if [ condition ]; then
                    echo "condition is true"
                else
                    echo "condition is false"
                fi

12) if-else-if statement:
                if [ condition ];then
                    echo "if condition is true"
                elif [ condition ]; then
                    echo "elif condition is true"
                else
                    echo "neither if nor elif condition is true"
                fi

13) switch case:
        read -p "Do you likes programming" ans
        case $ans in
            Yes|yes|y|Y)
                echo "Thats amazing"
                ;;
            No|no|n|N)
                echo "its easy lets start learning"
                ;;
            *)
                echo "its default case"
                ;;
        esac

14) for loop:
    A) For loop in range increment:
        for i in {1..10}
        do
        echo $i
        done
    B) For loop with increment:
        for i in {1..10..2}
        do
        echo $if
        done
    C) for loop in range decrement:
        for i in {10..1}
        do
        echo $i
        done
    D) for loop with decrement:
        for i in {10..1..2}
        do 
        echo $i
        done
    E) for((i=1;i<=10;i++))
        do
        echo $i
        done
    F) Break and continue statement statement
        for((i=1;i<=10;i+=2))
        do

        if[ $i -eq 2 ]; then
        continue
        fi

        if [ $i==5 ]; then
        break
        fi

        echo $i
        done
    G) infinite for loop
        for((;;))
        do
        echo "hello"
        sleep 1s
        done

15) while Loop:
    A)  i=0
    
        while((i<=10 || i<=5))
        do
        ((i+=1))
        if [ $i -eq 2 ]; then
        continue
        fi

        if [ $i -eq 10 ]; then
        break
        fi

        echo $i
        done

16) functions:
    A)  function_name(){

        } =====> this is function defination like in cpp without return type
        function_name=====> function call just need to write the function name
    B)  passing argument: we pass argument in similar way as we pass from terminal and we access then like $1, $2, $3 execute
        eg: function_name(){
            echo "first arg: $1"
            echo "second arg: $2"
        }
        function_name "hello" "amit sharma"
    C)  variable scope: read this article => https://www.javatpoint.com/bash-functions
    D)  return statement:
        D.1) to return numeric value in range [0,255]
            function_name(){
                return 12;
            }
            function_name
            echo "we get return value with the help of #?" ====> to extract the return value we use #? keyword
        D.2) to return the string values: we send the value to stdout using echo function
            function_name(){
                echo "passing the value to stdout using echo"
            }
            return_value="$(function_name)"
            echo "return value: $return value"
    E)  Overriding Comand: we can override the linux command by creating the function with the exact same name as of command
        eg: echo(){
            builtin echo "overriding the echo command"
            builtin echo $1
        }
        echo "this will call our function not inbuilt echo command"

        to access the inbuilt command we use the builtin keyword before command


17) Strings:
    str1="String1 dummy"
    str2="String2 dummy"
    A) equal operator: =
        if [ $str1 = $str2 ]; then
        if [[ $str1=$str2 ]]; then
    B) Not equal operator: !=
        if [ $str1 != $str2 ]; then
        if [[ $str1!=$str2 ]]; then
    C) less than operator: \<
        if [ $str1 \< $str2 ]; then
    D) greater than operator: \>
        if [ $str1 \> $str2 ]; then
    E) check whether the string length is more than 0: -n operand
        if [ -n $str1 ]; then
    F) check whether string length is 0: -z operand
        if [ -z $str1 ]; then
    G) Length of String:
        length=${#str}

